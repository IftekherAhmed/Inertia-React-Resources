# Complete Laravel, Inertia.js & React Guide - Part 3

## Adding Server-side Features (Continued)

### To Add Search in the Server Side

#### Backend Changes:
1. Add scope to your model:
```php
public function scopeSearch(Builder $query, ?string $search): Builder
{
    if (empty($search)) {
        return $query;
    }

    return $query->where(function (Builder $q) use ($search): void {
        $q->where('name', 'like', "%{$search}%")
            ->orWhere('description', 'like', "%{$search}%");
    });
}
```

2. Update service method to use search:
```php
public function getProductList(Request $request)
{
    $filters = [
        'search' => $request->input('search'),
        // ... other filters
    ];

    $query = Product::search($filters['search'] ?? null);
    // ... rest of implementation
}
```

#### Frontend Changes:
1. Add search input to your component:
```tsx
<Input
    type="text"
    placeholder="Search products..."
    value={searchQuery}
    onChange={handleSearchChange}
/>
```

2. Implement search handler:
```tsx
const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
    fetchProducts({ search: e.target.value, page: 1 });
};
```

### To Add Pagination in the Server Side

#### Backend Changes:
1. Add scope to your model:
```php
public function scopePaginateOrAll(Builder $query, int|string $perPage = 25, int $page = 1): Collection|Builder|LengthAwarePaginator
{
    if ($perPage === 'all' || $perPage === 0) {
        return $query->get();
    }

    return $query->paginate($perPage, ['*'], 'page', $page);
}
```

2. Update service method:
```php
public function getProductList(Request $request)
{
    $perPage = $request->input('per_page', 25);
    $page = $request->input('page', 1);

    $results = $query->paginateOrAll($perPage, $page);
    
    // Handle pagination response
    if ($perPage === 'all' || $perPage == 0) {
        $pagination = [
            'current_page' => 1,
            'last_page'    => 1,
            'per_page'     => 'all',
            'total'        => $results->count(),
        ];
        $products = $results;
    } else {
        $pagination = [
            'current_page' => $results->currentPage(),
            'last_page'    => $results->lastPage(),
            'per_page'     => $results->perPage(),
            'total'        => $results->total(),
        ];
        $products = $results->items();
    }

    return [
        'products'   => $products,
        'pagination' => $pagination,
    ];
}
```

#### Frontend Changes:
1. Add pagination component:
```tsx
<Pagination
    currentPage={pagination.current_page}
    totalPages={pagination.last_page}
    onPageChange={handlePageChange}
/>
```

2. Implement page change handler:
```tsx
const handlePageChange = (page: number) => {
    setCurrentPage(page);
    fetchProducts({ page });
};
```

### To Add Sort in the Server Side

#### Backend Changes:
1. Add scope to your model:
```php
public function scopeSortBy(Builder $query, string $sortBy, string $sortDirection = 'desc'): Builder
{
    return $query->orderBy($sortBy, $sortDirection);
}
```

2. Update service method:
```php
public function getProductList(Request $request)
{
    $filters = [
        'sort_by'        => $request->input('sort_by', 'id'),
        'sort_direction' => $request->input('sort_direction', 'desc'),
    ];

    $query = Product::sortBy($filters['sort_by'] ?? 'id', $filters['sort_direction'] ?? 'desc');
    // ... rest of implementation
}
```

#### Frontend Changes:
1. Add sort handler:
```tsx
const handleSort = (column: string) => {
    const newDirection = sortBy === column && sortDirection === 'asc' ? 'desc' : 'asc';
    setSortBy(column);
    setSortDirection(newDirection);
    fetchProducts({ sort_by: column, sort_direction: newDirection, page: 1 });
};
```

2. Add sort indicators to table headers:
```tsx
<th className="cursor-pointer" onClick={() => handleSort('name')}>
    Name
    {sortBy === 'name' && (
        sortDirection === 'asc' ? <ArrowUp size={14} /> : <ArrowDown size={14} />
    )}
</th>
```

### To Add Reset in the Server Side

#### Backend Changes:
No backend changes needed - just ensure your default values are set correctly in the service.

#### Frontend Changes:
1. Add reset handler:
```tsx
const resetTable = () => {
    setSearchQuery('');
    setPerPage(25);
    setCurrentPage(1);
    setSortBy('id');
    setSortDirection('desc');
    fetchProducts({ 
        search: '', 
        per_page: 25, 
        page: 1, 
        sort_by: 'id', 
        sort_direction: 'desc' 
    });
};
```

2. Add reset button:
```tsx
<Button onClick={resetTable}>Reset</Button>
```

## Step-by-Step CRUD Implementation with Post Model (Continued)

### Adding Reset

The reset functionality has already been implemented in the previous sections. The reset button clears all filters and returns the table to its default state.

## Summary

This comprehensive guide has shown you how to implement a complete CRUD system with a Post model that includes:

1. **Plain Index Table** - Basic table display with create/edit/delete actions
2. **Search** - Search functionality across multiple fields
3. **Sort** - Column sorting with visual indicators
4. **Filter** - Status filtering with dropdown selection
5. **Pagination** - Configurable pagination with page navigation
6. **Reset** - Complete reset of all filters to default state

Each section builds upon the previous one, demonstrating how to incrementally add features to your Laravel, Inertia.js, and React application. The implementation follows modern best practices and maintains clean separation of concerns between the backend and frontend.

## Additional Implementation Examples

### Creating the Post Create Page

File: `resources/js/pages/Post/Create.tsx`
```tsx
import { Head, Link, useForm } from '@inertiajs/react';
import AppLayout from '@/layouts/app-layout';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Switch } from '@/components/ui/switch';
import { useState } from 'react';

interface CreateProps {
  errors: Record<string, string>;
}

export default function Create({ errors }: CreateProps) {
  const { data, setData, post, processing } = useForm({
    title: '',
    description: '',
    image: '',
    is_published: false,
  });

  const submit = (e: React.FormEvent) => {
    e.preventDefault();
    post(route('post.store'));
  };

  return (
    <AppLayout>
      <Head title="Create Post" />
      
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Create Post</h1>
        <Button variant="outline" asChild>
          <Link href={route('post.index')}>Back to Posts</Link>
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>New Post</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={submit} className="space-y-6">
            <div>
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                value={data.title}
                onChange={(e) => setData('title', e.target.value)}
                className={errors.title ? 'border-red-500' : ''}
              />
              {errors.title && <p className="text-red-500 text-sm mt-1">{errors.title}</p>}
            </div>

            <div>
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={data.description}
                onChange={(e) => setData('description', e.target.value)}
                className={errors.description ? 'border-red-500' : ''}
              />
              {errors.description && <p className="text-red-500 text-sm mt-1">{errors.description}</p>}
            </div>

            <div>
              <Label htmlFor="image">Image URL</Label>
              <Input
                id="image"
                value={data.image}
                onChange={(e) => setData('image', e.target.value)}
                className={errors.image ? 'border-red-500' : ''}
              />
              {errors.image && <p className="text-red-500 text-sm mt-1">{errors.image}</p>}
            </div>

            <div className="flex items-center space-x-2">
              <Switch
                id="is_published"
                checked={data.is_published}
                onCheckedChange={(checked) => setData('is_published', checked)}
              />
              <Label htmlFor="is_published">Published</Label>
            </div>

            <div className="flex justify-end space-x-2">
              <Button variant="outline" asChild>
                <Link href={route('post.index')}>Cancel</Link>
              </Button>
              <Button type="submit" disabled={processing}>
                {processing ? 'Creating...' : 'Create Post'}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </AppLayout>
  );
}
```

### Creating the Post Edit Page

File: `resources/js/pages/Post/Edit.tsx`
```tsx
import { Head, Link, useForm } from '@inertiajs/react';
import AppLayout from '@/layouts/app-layout';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Switch } from '@/components/ui/switch';

interface Post {
  id: number;
  title: string;
  description: string | null;
  image: string | null;
  is_published: boolean;
  created_at: string;
  updated_at: string;
}

interface EditProps {
  post: Post;
  errors: Record<string, string>;
}

export default function Edit({ post, errors }: EditProps) {
  const { data, setData, put, processing } = useForm({
    title: post.title,
    description: post.description || '',
    image: post.image || '',
    is_published: post.is_published,
  });

  const submit = (e: React.FormEvent) => {
    e.preventDefault();
    put(route('post.update', post.id));
  };

  return (
    <AppLayout>
      <Head title="Edit Post" />
      
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Edit Post</h1>
        <Button variant="outline" asChild>
          <Link href={route('post.index')}>Back to Posts</Link>
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Edit Post</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={submit} className="space-y-6">
            <div>
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                value={data.title}
                onChange={(e) => setData('title', e.target.value)}
                className={errors.title ? 'border-red-500' : ''}
              />
              {errors.title && <p className="text-red-500 text-sm mt-1">{errors.title}</p>}
            </div>

            <div>
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={data.description}
                onChange={(e) => setData('description', e.target.value)}
                className={errors.description ? 'border-red-500' : ''}
              />
              {errors.description && <p className="text-red-500 text-sm mt-1">{errors.description}</p>}
            </div>

            <div>
              <Label htmlFor="image">Image URL</Label>
              <Input
                id="image"
                value={data.image}
                onChange={(e) => setData('image', e.target.value)}
                className={errors.image ? 'border-red-500' : ''}
              />
              {errors.image && <p className="text-red-500 text-sm mt-1">{errors.image}</p>}
            </div>

            <div className="flex items-center space-x-2">
              <Switch
                id="is_published"
                checked={data.is_published}
                onCheckedChange={(checked) => setData('is_published', checked)}
              />
              <Label htmlFor="is_published">Published</Label>
            </div>

            <div className="flex justify-end space-x-2">
              <Button variant="outline" asChild>
                <Link href={route('post.index')}>Cancel</Link>
              </Button>
              <Button type="submit" disabled={processing}>
                {processing ? 'Updating...' : 'Update Post'}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </AppLayout>
  );
}
```

## Best Practices and Tips

### 1. Error Handling
Always implement proper error handling in both backend and frontend:

Backend (in controller):
```php
public function store(StorePostRequest $request)
{
    try {
        $post = Post::create($request->validated());
        
        return redirect()->route('post.index')->with('success', 'Post created successfully.');
    } catch (\Exception $e) {
        return back()->with('error', 'Failed to create post: ' . $e->getMessage());
    }
}
```

Frontend (in component):
```tsx
const { data, setData, post, processing, errors } = useForm({
    title: '',
    description: '',
    // ... other fields
});

// Check for errors in the render method
{errors.title && <p className="text-red-500 text-sm mt-1">{errors.title}</p>}
```

### 2. Loading States
Implement loading states for better user experience:

```tsx
<Button type="submit" disabled={processing}>
    {processing ? (
        <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Processing...
        </>
    ) : (
        'Submit'
    )}
</Button>
```

### 3. Form Validation
Use Laravel's built-in validation with custom messages:

File: `app/Http/Requests/StorePostRequest.php` (enhanced)
```php
public function rules(): array
{
    return [
        'title' => 'required|string|max:255|unique:posts,title',
        'description' => 'nullable|string|max:1000',
        'image' => 'nullable|url|max:255',
        'is_published' => 'boolean',
    ];
}

public function messages(): array
{
    return [
        'title.required' => 'A title is required',
        'title.unique' => 'This title has already been taken',
        'description.max' => 'Description must not exceed 1000 characters',
        'image.url' => 'Please provide a valid URL for the image',
    ];
}
```

### 4. Security Considerations
- Always use Laravel's built-in authorization features
- Implement proper CSRF protection (automatically handled by Inertia.js)
- Use validated request data only
- Implement proper authentication and authorization checks

### 5. Performance Optimization
- Use database indexing for frequently searched columns
- Implement eager loading to avoid N+1 queries
- Use pagination for large datasets
- Cache frequently accessed data when appropriate

## Conclusion

This comprehensive guide has provided you with everything you need to build robust CRUD applications using Laravel, Inertia.js, and React. By following the patterns and examples shown here, you can:

1. Create maintainable and scalable applications
2. Implement common features like search, sort, filter, and pagination
3. Follow best practices for both backend and frontend development
4. Build user-friendly interfaces with modern React components
5. Maintain clean separation of concerns between different parts of your application

The modular approach demonstrated in this guide allows you to pick and choose which features to implement based on your specific requirements, making it easy to adapt to various project needs.